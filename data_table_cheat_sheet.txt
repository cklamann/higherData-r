Data.table

1. To sum and group by on multiple columns:

	a. the following sums two columns and groups them by year:

		summary<-big_one[,.(sum(als_cash_disbursed),sum(alu_cash_disbursed)),by=fall_year]
		
	d. this will sum two columns and put the sum in another column
		
		table["total"]<-table[,first]+table[,second]
	
	r. this will do the same as above (though it's been known to crash this computer)
		
		table["total"]<-table[,first + second + third]

	b. this will sum all the columns in the table and group by year:
		
		summary<-big_one[,lapply(.SD,sum),by=fall_year]
	
	c. this will do the same as above, grouping by unitid and year:
	
		summary<-big_one[,lapply(.SD,sum),by=.(unitid,fall_year)]
	
	e. this will convert the selected values to percentages
	
		new_table<-table[,lapply(.SD, FUN=function(x) x*100), by=list(unitid,fall_year,instnm)]
		
	f. this will multiply columns in j by a value in by
		
                real<-table[,lapply(.SD,function(x) x*(max_year_average/cpi[year==fall_year,average])),by=.(fall_year,unitid)]  
				
	notes on lapply():
	
		putting lapply in j is optional and must have .SD. If using .SDcols, this is NOT an lapply argument but a j argument. Note this is data.table only.
		
		for following examples:
			testTable<-data.table(first=c(1:10), second=c(11:20))
			testMean<-function(x,supp){
				mean(x+supp)
			}
		
		Note also that you can pass columns from table to lapply as arguments: lapply(testTable,testMean,second)
		If you want to iterate row-wise, use apply with margin arg set to 1, here you can also pass a column as arg: apply(testTable,1,testMean,second)
		
		If you have a function that takes a few arguments and they're vectors on the same table, you can pass them to mapply, which is very handy, like so:
		cleanCountiesApply<-mapply(fixCountyVec,orgFiltered[,county],orgFiltered[,addr_state])

2. Searching and filtering

	a. this will return a 2 column data.table containing the last names and values in the "Comments" column that contain a digit 

                filtered<-as.data.table(refunds[,lapply(.SD, function(x) grep("[:digit:]",x)),by="Last Name",.SDcols=c("Comment")])
        
	b. there is a %like% operator in R. The will return every row that doesn't have "mailed" in it

		filtered<-as.data.table(refunds[!(Comment %like% "mailed")])	  
		
	c. remove all nas
		
		final[complete.cases(final)]

				
3. Casting

	a. filteredTable<-dcast.data.table(filteredTable, UNITID~SGTYPE, value.var="HRTOTLT",sum, fill=as.integer(0))
	
		this is for a three value table, and it will sum the values of anything with the same unitid and type
	
	b. filteredTable<-dcast.data.table(filteredTable, unitid~arank, value.var="avgsal",mean, fill=as.integer(0))
	
		in this case there are multiple aranks and unitids, aranks and ids will grouped, ranks cast, and avgsals averaged
		
		
4. Melting
	
	b. general note, this gives a 3-column table: one column is unitid, one is variable, one is value
	

5. Replacing
	
	a. This will replace dots with zeroes
	
		lapply(filteredTable, function(x) gsub(".",0,x))

	b. This will replace any NaN's with NA
	
	    rapply( full_table, f=function(x) ifelse(x=="NaN",_na_character_,x), how="replace" )


5.5 ggplot2

	a. This will plot the increases for all schools returned by check change in the reals table
	   We assume that instnm has been merged into the reals dataTable

	   qplot(x = fall_year,y = total,data = reals[unitid %in% plum_schools[,unitid]],
		geom = "line",group=1)+facet_wrap(~instnm+unitid)

	b. ggsave(sprintf("%s.pdf", obj_name)) will save a ggobj as a pdf.
		

6. Misc

	a. if you want all possible comboes of two vectors, use expand.grid
		
		unique_combos<-expand.grid(unitid_list,2001:2015) // this will return all 22275 unique year+ID combi 	tions
	
	b. converting to a new type:
	
		new_year<-all[,lapply(.SD,as.integer),.SDcols="fall_year"] //makes formerly char fall_year into an integer vector
		all[,fall_year:=new_year] //reassigns it

	c. This will return a vector of unitids with jumps in real number values; it will return one column of unitids and one of pct change
           In future, you can pass result ids to graph and review
			problems<-checkChange(melted_dataTable = makeLotsReal(this_connection = mydb,dataTable = wags,this_cpi_table = cpi_table),this_pct_less = .50,this_pct_more = 1.5)



99999. Pending

Function to chunk your graphs with many facets:

library(ggplot2)
library(reshape2)

Ex <- read.csv("C:/Users/Thomas/Desktop/StackOverflowEx (3).csv")
gg <- melt(Ex,  id = c("Item", "Total", "Admin"))

# put in number of plots here
noPlots <- 4
# save all variables in a seperate vector to select in for-loop
allVars <- unique(gg$variable)
noVars <- length(allVars)

# indices for plotting variables
plotSequence <- c(seq(0, noVars-1, by = noPlots), noVars)

# pdf("plotpath.pdf") # uncomment to save the resulting plots in a pdf file
# loop over the variables to plot
for(ii in 2:length(plotSequence)){
  # select start and end of variables to plot
  start <- plotSequence[ii-1] + 1
  end <- plotSequence[ii]

  # subset the variables and save new temporary data.frame
  tmp <- subset(gg, variable %in% allVars[start:end])
  cat(unique(tmp$variable), "\n")

  # generate plot
  p <- ggplot(tmp,  aes(x = Total, y = Admin))+
    geom_point(colour = "dark green", size = 1.5)+
    geom_point(aes(y = value, color = variable))+
    geom_smooth(aes(y = value, fill = variable), 
                method = loess, size = 1, linetype = 1, se = T)+
    facet_wrap(~variable, ncol = 2, nrow = 1000)+
    ylim(0, 1)+
    labs(x = "Expected",  y = "Admin")
  print(p)
}



pending