data.table notes

fread() will read a .csv fast with only file name as input

Unlike data.frames, columns of character type are never converted to factors by default.

ordering: ans <- flights[order(origin, -dest)]

if you're refering to columns by names, need with=false: ie,
ans <- flights[, c("arr_delay", "dep_delay"), with=FALSE]

can use bang to deselect columns: ans <- flights[, !c("arr_delay", "dep_delay"), with=FALSE]

get the number of flights by origin: ans <- flights[, .(.N), by=.(origin)]

here it is by origin and destination:

ans <- flights[carrier == "AA", .N, by=.(origin,dest)]

keyby can be used instead of by in order to order groups: 

ans <- flights[carrier == "AA", .(mean(arr_delay), mean(dep_delay)), keyby=.(origin, dest, month)]

We can tack expressions one after another, forming a chain of operations, i.e., DT[ ... ][ ... ][ ... ].

by can also accept expressions: ans <- flights[, .N, .(dep_delay>0, arr_delay>0)]

you already know this: DT[, lapply(.SD, mean), by=ID] will find the mean for the subset of columns by ID
here is how .DScols works:

flights[carrier == "AA",                     ## Only on trips with carrier "AA"
        lapply(.SD, mean),                   ## compute the mean
        by=.(origin, dest, month),           ## for every 'origin,dest,month'
        .SDcols=c("arr_delay", "dep_delay")  ## for just those specified in .SDcols



here's where you can find the reshaping info: 
https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html

don't need to load reshape2 anymore, and if you load it after loading data.table, it will fuck up

basic melt() syntax:

DT.m1 = melt(DT, id.vars = c("family_id", "age_mother"), 
                measure.vars = c("dob_child1", "dob_child2", "dob_child3"))

note that the variable values are turned into factors, can set variable.factor=FALSE to change to character

basic casting syntax:

dcast(DT.m1, family_id + age_mother ~ child, value.var = "dob")

re:tilde -- "dcast uses formula interface. The variables on the LHS of formula represents the id vars and RHS the measure vars."

then, of course, if you are casting and won't have a single value per cell, you need to specify and aggregating function:

dcast(DT.m1, family_id ~ ., fun.agg = function(x) sum(!is.na(x)), value.var = "dob")


--using :=

this will add 2 new columns with the names "speed" and "delay"
flights[, c("speed", "delay") := list(distance/(air_time/60), arr_delay + dep_delay)]

you can also subassign a value based on a condition:

flights[hour == 24L, hour := 0L] (the L means 'make it an integer')

to view the result immediately (since assigning by reference works invisible

flights[, max_speed := max(speed), by=.(origin, dest)]

can also do this with multiple columns:

in_cols  = c("dep_delay", "arr_delay")
out_cols = c("max_dep_delay", "max_arr_delay")
flights[, c(out_cols) := lapply(.SD, max), by = month, .SDcols = in_cols]

you can also, of course, use it in functions:

foo <- function(DT) {
  DT[, speed := distance / (air_time/60)]
  DT[, .(max_speed = max(speed)), by=month]
}
ans = foo(flights)
head(ans) --- (*This will add the column "speed" to flights, since := works by reference*)
#    month max_speed
# 1:     1  535.6425
# 2:     2  535.6425
# 3:     3  549.0756
# 4:     4  585.6000
# 5:     5  544.2857
# 6:     6  608.5714






